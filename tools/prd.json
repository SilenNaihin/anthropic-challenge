{
  "project": "VLIW SIMD Optimization Tools",
  "goal": "Build tools to push cycle count below 1,487 (currently at 8,500)",
  "current_cycles": 8500,
  "target_cycles": 1487,
  "tools": [
    {
      "id": "slot_analyzer",
      "name": "Slot Utilization Analyzer",
      "file": "slot_analyzer.py",
      "status": "completed",
      "priority": "P0",
      "description": "Analyzes instruction streams for slot utilization and packing opportunities",
      "features": {
        "overall_utilization": true,
        "per_engine_breakdown": true,
        "histogram": true,
        "packing_opportunities": true,
        "packing_by_type": true,
        "json_output": true,
        "dependency_analysis": true,
        "critical_path": true,
        "recommendations": true,
        "kernel_diff": true,
        "rich_output": true,
        "save_load_kernels": true
      },
      "usage": "python tools/slot_analyzer.py [--packing] [--deps] [--recommendations] [--compare k1.json k2.json] [--save file.json]",
      "future_improvements": [
        "Full DAG for critical path (currently adjacent-only)",
        "Hot register detection",
        "Instruction latency model",
        "Modularize into separate files"
      ]
    },
    {
      "id": "dependency_graph",
      "name": "Dependency Graph Builder",
      "file": "dependency_graph/dependency_graph.py",
      "status": "completed",
      "priority": "P0",
      "description": "Build full DAG of instruction dependencies (RAW, WAR, WAW hazards)",
      "features": {
        "build_dag": true,
        "critical_path": true,
        "parallelism_potential": true,
        "hot_registers": true,
        "rich_output": true,
        "json_output": true
      },
      "usage": "python tools/dependency_graph/dependency_graph.py [--json] [--top N]",
      "value": "Essential for understanding what PREVENTS packing"
    },
    {
      "id": "vliw_packer",
      "name": "VLIW Auto-Packer",
      "file": "vliw_packer/vliw_packer.py",
      "status": "completed",
      "priority": "P0",
      "description": "Automatically pack independent instructions into VLIW bundles",
      "features": {
        "dependency_aware": true,
        "respects_slot_limits": true,
        "priority_scheduling": true,
        "outputs_packed_kernel": true,
        "statistics_report": true
      },
      "usage": "python tools/vliw_packer/vliw_packer.py [--output FILE] [--verbose]",
      "value": "Achieves ~1.4x speedup automatically"
    },
    {
      "id": "cycle_profiler",
      "name": "Cycle Profiler",
      "file": "cycle_profiler/cycle_profiler.py",
      "status": "completed",
      "priority": "P1",
      "description": "Break down cycles by code section (hash, memory, index calc)",
      "features": {
        "phase_tagging": true,
        "per_round_breakdown": true,
        "hotspot_identification": true,
        "rich_output": true,
        "json_output": true,
        "optimization_recommendations": true,
        "exclusive_cycle_tracking": true
      },
      "usage": "python tools/cycle_profiler/cycle_profiler.py [--all] [--detailed] [--per-round] [--recommendations] [--json]",
      "value": "Know WHERE cycles are spent, not just how many"
    },
    {
      "id": "memory_analyzer",
      "name": "Memory Access Pattern Analyzer",
      "file": "memory_analyzer/memory_analyzer.py",
      "status": "completed",
      "priority": "P1",
      "description": "Analyze load/store patterns for vectorization opportunities",
      "features": {
        "access_pattern_detection": true,
        "stride_analysis": true,
        "vectorization_blockers": true,
        "address_source_tracking": true,
        "rich_output": true,
        "json_output": true,
        "recommendations": true
      },
      "usage": "python tools/memory_analyzer/memory_analyzer.py [--json] [--verbose] [--no-color]",
      "value": "Reveals why vload/vstore can't be used (tree lookups = scattered addresses)"
    },
    {
      "id": "hash_pipeline",
      "name": "Hash Pipeline Analyzer",
      "file": "hash_pipeline/hash_pipeline.py",
      "status": "completed",
      "priority": "P1",
      "description": "ILP analysis tool for 6-stage hash function software pipelining",
      "features": {
        "stage_dependency_analysis": true,
        "intra_stage_parallelism": true,
        "inter_element_pipelining": true,
        "scheduling_strategies": true,
        "theoretical_minimum_calc": true,
        "realistic_estimates": true,
        "batch_size_analysis": true,
        "code_generation_hints": true,
        "schedule_visualization": true,
        "json_output": true
      },
      "usage": "python tools/hash_pipeline/hash_pipeline.py [--elements N] [--visualize] [--codegen] [--realistic]",
      "value": "Hash is the hottest code path (4096 calls) - understanding ILP is critical",
      "notes": [
        "Provides THEORETICAL lower bounds, not achievable targets",
        "Real implementations will have additional overhead",
        "Always validate with slot_analyzer on actual code"
      ]
    },
    {
      "id": "constraint_validator",
      "name": "Constraint Validator",
      "file": "constraint_validator/constraint_validator.py",
      "status": "completed",
      "priority": "P2",
      "description": "Static checking of kernel before runtime",
      "features": {
        "slot_limit_check": true,
        "scratch_overflow_check": true,
        "same_cycle_hazard_check": true,
        "register_usage_validation": true,
        "rich_output": true,
        "json_output": true,
        "strict_mode": true
      },
      "usage": "python tools/constraint_validator/constraint_validator.py [--json] [--strict] [--kernel FILE]",
      "value": "Catch errors before slow runtime failures"
    },
    {
      "id": "transforms",
      "name": "Transformation Library",
      "file": "transforms.py",
      "status": "not_started",
      "priority": "P2",
      "description": "Codified transformations: unroll, vectorize, pipeline",
      "features": {
        "loop_unroll": false,
        "vectorize_batch": false,
        "software_pipeline": false,
        "hoist_invariants": false
      },
      "value": "Reduces manual errors in mechanical transforms"
    },
    {
      "id": "kernel_diff",
      "name": "Kernel Diff Tool",
      "file": "kernel_diff.py",
      "status": "not_started",
      "priority": "P2",
      "description": "Compare two kernel versions (cycles, utilization, structure)",
      "features": {
        "cycle_comparison": false,
        "utilization_diff": false,
        "instruction_diff": false
      },
      "value": "Track impact of each optimization"
    },
    {
      "id": "optimization_loop",
      "name": "Optimization Loop Runner",
      "file": "optimize.py",
      "status": "not_started",
      "priority": "P3",
      "description": "Meta-tool that runs profile->analyze->transform->validate loop",
      "features": {
        "automated_profiling": false,
        "bottleneck_detection": false,
        "transform_application": false,
        "regression_checking": false
      },
      "value": "Automates the optimization search process"
    }
  ],
  "libraries_to_install": [
    {"name": "networkx", "purpose": "Dependency graphs", "installed": false},
    {"name": "rich", "purpose": "Terminal output", "installed": false},
    {"name": "ortools", "purpose": "Constraint solving for scheduling", "installed": false}
  ],
  "milestones": [
    {"cycles": 18532, "name": "2-hour starting point", "achieved": true},
    {"cycles": 8500, "name": "Current position", "achieved": true},
    {"cycles": 2164, "name": "Opus 4 many hours", "achieved": false},
    {"cycles": 1790, "name": "Opus 4.5 casual", "achieved": false},
    {"cycles": 1487, "name": "TARGET: Opus 4.5 11.5hr", "achieved": false}
  ]
}
